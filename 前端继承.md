# 继承

## 类继承
```
    // 声明父类
    function superClass() {
        this.name = ['superClass']
    }
    // 声明子类
    function subClass() {}
    // 将子类得原型指向父类 对父类进行实例化
    subClass.prototype = new superClass()
    // 子类
    var instance1 = new subClass()
    // 子类
    var instance2 = new subClass()

    console.log(instance2.name) // ['superClass']
    // 更改子类得属性
    instance1.name.push('instance')

    console.log(instance1.name) // ['superClass','instance']

    console.log(instance2.name) // ['superClass','instance']

    缺点：
    多个实例对引用类型的操作会被篡改。 instance1 push操作会导致 instance2得属性发生变化，这在编程中很容易出现bug  
    而且子类实现得继续是靠其原型 prototype 对父类得实例化 实现得，因此再创建父类得时候，是无法向父类传递参数，因而再实例化得时候也无法对父类构造函数内得属性进行初始化
```
## 构造函数继承

```
    // 声明父类
    function superClass() {
        this.name = ['superClass']
    }
    // 声明子类
    function subClass() {
        superClass.call(this)
    }
    // 将子类得原型指向父类 对父类进行实例化
    // 子类
    var instance1 = new subClass()
    // 子类
    var instance2 = new subClass()

    // 更改子类得属性
    instance1.name.push('instance')

    console.log(instance1.name) // ['superClass','instance']

    console.log(instance2.name) // ['superClass','instance']

    构造函数最主要得 核心就是 改变函数得作用环境 ，因此再子类中，对superClass函数调用call 改变了父类得作用环境 由于父类是给this 绑定属性得 因此子类自然得继承了父类得共有属性
    但是由于这种类型得继承没有涉及到prototype 所以父类得原型方法 不会被子类继承 ，所以这样创建出来得实例都回单独拥有一份 而不能共有，
    未了解决代码复用 综合了类继承和构造函数继承 推出了组合式继承
```
### 组合式继承

